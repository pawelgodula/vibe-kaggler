# Generates polynomial and interaction features for specified numerical columns.

"""
Extended Description:
This function uses scikit-learn's PolynomialFeatures to create higher-degree
and interaction terms from a set of input features in a Polars DataFrame.
It converts the specified features to NumPy, generates polynomial features,
converts them back to Polars columns with appropriate names, and appends
them to the original DataFrame.
"""

import polars as pl
import numpy as np
from sklearn.preprocessing import PolynomialFeatures
from typing import List

def create_polynomial_features(
    df: pl.DataFrame,
    features: List[str],
    degree: int = 2,
    interaction_only: bool = False,
    include_bias: bool = False,
    new_col_prefix: str = "poly_" # Added prefix for clarity
) -> pl.DataFrame:
    """Generates polynomial and interaction features and appends them to the DataFrame.

    Args:
        df (pl.DataFrame): Polars DataFrame containing the input features.
        features (List[str]): List of numerical column names to use for generating features.
        degree (int, optional): The degree of the polynomial features. Defaults to 2.
        interaction_only (bool, optional): If True, only interaction features are produced.
                                         Defaults to False.
        include_bias (bool, optional): If True, include a bias column (feature = 1).
                                     Defaults to False.
        new_col_prefix (str, optional): Prefix to add to the generated feature names.
                                        Defaults to "poly_".

    Returns:
        pl.DataFrame: The original DataFrame with the generated polynomial features appended.
                      Column names for new features are generated by PolynomialFeatures
                      and prefixed with `new_col_prefix`.

    Raises:
        pl.exceptions.ColumnNotFoundError: If any specified feature is not found.
        pl.exceptions.ComputeError: If features are not numerical or conversion/transform fails.
    """
    df_out = df.clone()

    # Input validation
    missing_features = [f for f in features if f not in df_out.columns]
    if missing_features:
        raise pl.exceptions.ColumnNotFoundError(f"Features not found in DataFrame: {missing_features}")
    
    # Check numeric types using Polars dtypes
    non_numeric_features = [f for f in features if not df_out[f].dtype.is_numeric()]
    if non_numeric_features:
         raise pl.exceptions.ComputeError(f"Non-numeric features specified for polynomial generation: {non_numeric_features}")

    poly = PolynomialFeatures(
        degree=degree,
        interaction_only=interaction_only,
        include_bias=include_bias,
        order='C' # Default, keeps order consistent
    )

    # Extract features as NumPy for scikit-learn
    try:
        features_np = df_out.select(features).to_numpy()
    except Exception as e:
        raise pl.exceptions.ComputeError(f"Could not convert features {features} to NumPy: {e}")

    # Fit and transform
    try:
        poly_features_array = poly.fit_transform(features_np)
        poly_feature_names_raw = poly.get_feature_names_out(features)
        poly_feature_names = [f"{new_col_prefix}{name}" for name in poly_feature_names_raw]
    except Exception as e:
        print(f"Error during PolynomialFeatures fit_transform: {e}")
        raise pl.exceptions.ComputeError(f"PolynomialFeatures processing failed: {e}")

    # Create Polars DataFrame with new features
    # Ensure generated features are Float64 for consistency
    try:
        df_poly_new = pl.DataFrame(
            poly_features_array,
            schema=poly_feature_names
        ).with_columns([
            pl.col(name).cast(pl.Float64) for name in poly_feature_names
        ])
    except Exception as e:
         raise pl.exceptions.ComputeError(f"Could not create Polars DataFrame from polynomial features: {e}")

    # Append new features to the original DataFrame
    df_out = pl.concat([df_out, df_poly_new], how="horizontal")

    return df_out 